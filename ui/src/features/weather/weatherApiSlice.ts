// Need to use the React-specific entry point to import `createApi`
import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react"
import { DailyWeather, HourlyWeather, WeatherRequest, WeatherResponse } from "./types";
import { format } from "date-fns";


// Define a service using a base URL and expected endpoints
export const weatherApiSlice = createApi({
  baseQuery: fetchBaseQuery({ baseUrl: "https://api.open-meteo.com/v1/forecast" }),
  reducerPath: "weatherApi",
  // Tag types are used for caching and invalidation.
  tagTypes: ["Weather"],
  endpoints: build => ({
    // Supply generics for the return type (in this case `QuotesApiResponse`)
    // and the expected query argument. If there is no argument, use `void`
    // for the argument type instead.
    getWeather: build.query<DailyWeather[], WeatherRequest>({
      query: (request: WeatherRequest) => {
        let url = `?latitude=${request.latitude}&longitude=${request.longitude}&forecast_days=${request.forecastDays}`

        url += '&timezone=America%2FHalifax'
        if (request.hourly && request.hourly.length > 0) {
          url += `&hourly=${request.hourly.join(',')}`
        }
        if (request.daily && request.daily.length > 0) {
          url += `&daily=${request.daily.join(',')}`
        }
        return url;
      },
      // Pick out data and prevent nested properties in a hook or selector
      transformResponse: (response: WeatherResponse) => {
        const dailyWeatherMap = new Map<string, DailyWeather>();

        // Parse daily weather stats
        response.daily.time.forEach((_, index) => {
          const daily = {
            time: new Date(response.daily.time[index] + 'T00:00'),
            sunrise: new Date(response.daily.sunrise[index]),
            sunset: new Date(response.daily.sunset[index]),
          } as DailyWeather
          dailyWeatherMap.set(daily.time.toUTCString(), daily);
         });


         // Parse hourly wather stats
        response.hourly.time.forEach((time, index) => {
          const hourly = {
            index: index,
            hour: format(new Date(response.hourly.time[index]), 'h aa'),
            hourDate: new Date(response.hourly.time[index]),
            time: new Date(response.hourly.time[index]),
            temperature: response.hourly.temperature_2m[index],
            rain: response.hourly.rain[index],
          } as HourlyWeather
          const date = new Date(time.substring(0, 10) + 'T00:00');

          if (dailyWeatherMap.has(date.toUTCString())) {
            const dailyWeather = dailyWeatherMap.get(date.toUTCString());
            if (!dailyWeather) {
              throw new Error('No Daily Entry found')
            }
            if (!dailyWeather.hourly) {
              dailyWeather.hourly = []
            }
            dailyWeather.hourly.push(hourly)
            dailyWeatherMap.set(date.toUTCString(), dailyWeather)
          }
         })

        return [...dailyWeatherMap.values()]
      },
      // `providesTags` determines which 'tag' is attached to the
      // cached data returned by the query.
      providesTags: (_result, _error) => [{ type: "Weather" }],
    }),
  }),
})

// Hooks are auto-generated by RTK-Query
// Same as `quotesApiSlice.endpoints.getQuotes.useQuery`
export const { useGetWeatherQuery } = weatherApiSlice
